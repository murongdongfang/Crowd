# day1
+ spring整合mybatis的时候，必须要在dao接口上面标注@mapper或者@component注解，这样Mybatis就能为接口动态生成子类
如果每个接口标注@Mapper或者@Component太麻烦，可以使用@MapperScan或者`<mybatis-spring:scan base-package="c"></mybatis-spring:scan>`
批量扫描生成接口子类（@Mapper注解是mybatis3以后引入，作用是mybatis动态代理的子类可以注入springIOC容器。
除了@mapper是写在接口上，其他像容器注入组件的注解都是写在类上。）在早前的mybatis版本中可以无需再接口上面标注@mapper注解，
但是要使用`<bean id="mapperScannerConfigurer" class="org.mybatis.spring.mapper.MapperScannerConfigurer">
</bean>`将mybatis动态代理生成的子类加入容器中。
+ Spring的配置文件太过于庞大的时候建议将配置文件分拆成为多个配置文件，
dao，service，web每一层都有一个配置文件，
使用`<import resource="classpath:spring*.xml"></import>` 将多个配置文件组合这样在配置web.xml时候
```xml
<context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>classpath:spring-persist-tx.xml</param-value>
  </context-param>
``` 
也可以不写<import></import>采用模糊匹配，这样多个spring的xml如果其中一个引用到了另外一个xml的bean时ide报错，运行正常。
```xml
<context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>classpath:spring-persist-*.xml</param-value>
  </context-param>
```
+ 在基于xml的声明式事务配置中，tx:method是必须要配置的，如果没有配置，那么事务对这个方法就不生效，即使事务存在默认配置。
+ [classpath和classpath*区别](https://www.cnblogs.com/chenmingjun/p/10264644.html)
+ [classpath和classpath应用场景](https://www.cnblogs.com/chenmingjun/p/10264644.html)
+ 400错误，一般是请求参数有问题。
+ JSP或者html的base标签为页面上的所有链接规定默认地址或默认目标。浏览器会从当前文档的 URL 中提取相应的元素来填写相对 URL,构成完整的请求地址。 
`<base href="http://${pageContext.request.serverName }:${pageContext.request.serverPort }${pageContext.request.contextPath }/"/>`
**但是如果其他的url地址要想拼接base标签的地址url前不能加/**
+ idea新版会自动为web工程增加一个ContextPath，部署的时候一定要修改，否则会造成404
+ 使用ajax+@requestBody页面无法在控制器实现跳转，要想跳转只能够通过JS跳转
+ maven项目clean或者install要用lifeCycle里的，不要用Plugins里边的
# day2
+ 配置登陆拦截器除了可以实现HandlerInterceptor接口之外也可以继承HandlerInterceptorAdaptor类，
InterceptorAdaptor有默认实现，只用选择重写的方法即可。
+ 配置异常处理的时候基于xml和基于注解的异常处理都需要配置
+ `<c:if test="${!empty requestScope.pageInfo.list }">`
+ 使用任何mybatis插件一定不要忘记再spring或者是mybatis配置文件中注册！！！！
+ mybatis如果mapper的SQL映射配置文件和mapper放在同一路径，要再maven的pom文件中
配置，否则打包的时候不会打包package里边的xml文件
+ 使用ajax传递数据，如果data属性是一个对象的话，那么ajax传递给服务器的数据就是form-data
如果调用JSON.stringify将一个对象转化成为Json字符串的话，此时必须要加一个请求头属性`contextType:"application/json;charset=utf-8`
ajax可以设置为acync属性为同步请求或者异步请求，ajax常用的属性**url,data,dataType,contentType,success,async,error**
+ 给一个标签绑定事件监听函数，如果这个函数返回值是false表示取消这个标签的默认行为，比如a标签绑定click返回false，表示不跳转
+ 再jQuery中click等传统的事件绑定不能绑定在动态生成的标签上面，如果需要再动态生成的标签上面绑定事件需要用到on事件  
绑定方法：首先找到动态生成标签的父标签，这个父标签必须是一个静态的标签，然后再这个静态标签上绑定on事件,  
传入要绑定的事件，动态标签选择器，和回调函数   
但是我们可以通过传统的方式获取动态生成标签上的属性值。 
+ jQuery中prop和attr函数的区别对于HTML元素本身就带有的固有属性，在处理时，使用prop方法。    
对于HTML元素我们自己自定义的DOM属性，在处理时，使用attr方法。     
具有 true 和 false 两个属性的属性，如 checked, selected 或者 disabled 使用prop()  
+ 如果工程中的js代码改变了，浏览器中的js代码没有改变可能是浏览器的缓存原因，要及时清空缓存  
+ Mybatis的mapper配置文件insert，update，delete都有返回值，返回值就是SQL语句执行成功的行数
所以我们可以直接将mapper接口的方法声明为int或者void。其中如果主键是自增的，我们插入完成一条数据想要获取这个主键
可以通过配置 `<insert id="" useGeneratedKeys="true" keyColumn=""></insert>`  
这样insert的SQL语句执行成功之后返回值就不是成功的条数，而是插入成功行的主键值
+ springBoot 1.x基于的是spring4，spirngBoot2.x基于的是spring5。相比于spring4而言spring5
使用的是jdk8，使用了大量jdk8的新特性。所以使用springboot2.x的最低版本就是jdk8
+ spring和配置有关的注解以及标签`<import></import>`, `<context:property-placeholder location="classpath:aaa">配合@value("${}"}</context:property-placeholder>`
`@PropertySource(value = "classpath:")配合@value("${}"}` `@ConfigurationProperties(prefix = "person")`
